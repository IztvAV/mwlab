# mwlab/data_gen/base.py
"""
Базовые абстракции подсистемы **mwlab.data_gen**
================================================
Данный модуль определяет _контракты_ (абстрактные классы) для трёх
непосредственно взаимодействующих звеньев пайп‑лайна генерации данных:

1. **ParamSource**  – выдаёт уникальные наборы параметров (dict‑ы).  Источник
   может быть конечным (список, CSV‑файл) или бесконечным (онлайн‑DOE).  Все
   методы, связанные с распределёнными вычислениями (*reserve*, *mark_done*,
   *mark_failed*), по умолчанию делают ничего – их переопределяет конкретная
   реализация.

2. **DataGenerator** – чистая функция «batch параметров → batch данных».
   Генератор не знает где лежит Source и куда Writer складывает результат; он
   может требовать внешних ресурсов (HFSS‑сессия, GPU) – для этого класс
   является контекст‑менеджером.

3. **Writer** – принимает результаты генерации и сохраняет их в нужный backend
   (каталог .sNp, монолитный HDF5, in‑memory список …).  По умолчанию Writer
   потокобезопасен _только_ если это гарантирует конкретная реализация.

Важно: **Сам модуль _не содержит_ управляющего цикла**.  Этим занимается
отдельный компонент – *Runner* (см. ``mwlab.data_gen.runner``), который клеит
Source, Generator и Writer, управляет многопоточностью, прогресс‑баром и
корректным завершением.
"""

from __future__ import annotations

import abc
from typing import Any, Iterable, Iterator, Mapping, Sequence, Tuple, TYPE_CHECKING, Union
import contextlib

# ---------------------------------------------------------------------------
# Type aliases – единая терминология по всему пакету
# ---------------------------------------------------------------------------
ParamDict  = Mapping[str, Any]      # один набор входных параметров (имеет __id)
MetaDict   = Mapping[str, Any]      # произвольная мета‑информация
Batch      = Sequence[ParamDict]    # пакет параметров одинаковой длины
MetaBatch  = Sequence[MetaDict]     # пакет метаданных той же длины, что Batch

# «Сырой» результат генератора может быть практически любым.
# Сам Writer решает – понимает он этот объект или выкинет исключение.
if TYPE_CHECKING:  # чтобы не тянуть тяжёлые импорты во время рантайма
    from mwlab.io.touchstone import TouchstoneData  # pragma: no cover
    import torch                                    # pragma: no cover
    Output = Union["TouchstoneData", "torch.Tensor", Any]
else:
    Output = Any

Outputs = Sequence[Output]        # пакет результатов такой же длины, как Batch

# ---------------------------------------------------------------------------
# 1. ParamSource – абстрактный интерфейс источника параметров
# ---------------------------------------------------------------------------
class ParamSource(abc.ABC):
    """Итерируемый источник `dict`‑ов параметров.

    * Каждый dict *обязан* содержать ключ ``"__id"`` – уникальный идентификатор
      точки (строка).  Это требование упрощает логику Writer‑ов и системы
      восстановления после падения.
    * Класс является контекст‑менеджером, чтобы при необходимости открыть файл,
      БД‑соединение или сетевой ресурс.
    * Методы :py:meth:`reserve`, :py:meth:`mark_done`, :py:meth:`mark_failed`
      нужны для распределённых сценариев; дефолтные реализации ничего не
      делают.
    """

    # ------------------------------------------------------- базовый протокол
    @abc.abstractmethod
    def __iter__(self) -> Iterator[ParamDict]:
        """Должен вернуть *итератор* уникальных ``ParamDict``.

        Длина источника может быть неизвестна, поэтому метод ``__len__`` по
        умолчанию **не** объявляем.  Если конкретный Source знает точную длину –
        пусть реализует ``__len__`` самостоятельно.
        """

    # ----------------------- контекст‑менеджер (обычно достаточно pass)
    def __enter__(self):  # noqa: D401
        return self

    def __exit__(self, exc_type, exc, tb):  # noqa: D401
        # Возвращаем False, чтобы возможное исключение не проглатывалось
        return False

    # ------------------------------------------------- fault‑tolerance hooks
    def reserve(self, ids: Sequence[str]):  # noqa: D401
        """Отметить набор *ids* как «захваченные» текущим воркером."""
        pass

    def mark_done(self, ids: Sequence[str]):  # noqa: D401
        """Отметить *ids* как успешно обработанные."""
        pass

    def mark_failed(self, ids: Sequence[str], exc: Exception):  # noqa: D401
        """Отметить *ids* как **failed**; *exc* – причина.

        По умолчанию точку зрения Source это не интересует, но CSV‑/DB‑sources
        могут сохранить текст ошибки прямо в таблицу (для последующего анализа).
        """
        pass

# ---------------------------------------------------------------------------
# 2. DataGenerator – абстрактный «производитель» данных
# ---------------------------------------------------------------------------
class DataGenerator(abc.ABC):
    """Преобразует батч параметров → батч данных (+ метаданные).

    Генератор **не** содержит внешнего цикла – только одну функцию
    :py:meth:`generate`.  Используем контекст‑менеджер для открытия/закрытия
    тяжёлых ресурсов (HFSS, лицензия CST, CUDA‑контекст …).
    """

    # ----------------------- контекст‑менеджер
    def __enter__(self):  # noqa: D401
        return self

    def __exit__(self, exc_type, exc, tb):  # noqa: D401
        return False

    # ----------------------- необязательные pre-hooks (по умолчанию no-op)
    def preprocess(self, params: Mapping[str, Any]) -> Mapping[str, Any]:
        """
        Хук предварительной обработки ОДНОЙ точки параметров.

        По умолчанию возвращает входной dict без изменений.

        Замечания
        ---------
        * РЕКОМЕНДАЦИЯ: не изменяйте ключ ``"__id"``.
          Идентификатор используется Runner-ом для резервирования
          и отметок done/failed в Source.
        * Здесь удобно делать легкую валидацию, нормализацию форматов
          (например, разворот скаляров в вектора) и пр.
        """
        return params

    def preprocess_batch(self, batch: Batch) -> Batch:
        """
        Хук предварительной обработки ВСЕГО батча параметров.

        По умолчанию возвращает входной батч без изменений.

        Замечания
        ---------
        * Длина батча ДОЛЖНА сохраниться неизменной.
        * РЕКОМЕНДАЦИЯ: не меняйте ``"__id"`` для элементов.
          Если нужно обогатить параметры — делайте это «внутри» dict-ов.
        * Подходит для операций, которые удобнее делать «оптом»,
          например, векторные трансформации.
        """
        return batch

    # ----------------------- обязательный метод
    @abc.abstractmethod
    def generate(self, params_batch: Batch) -> Tuple[Outputs, MetaBatch]:
        """Синхронно обрабатывает *params_batch*.

        Требования к возвращаемым значениям:
        * ``len(outputs)  == len(params_batch)``
        * ``len(meta)     == len(params_batch)``

        Runner будет это проверять.  При несоответствии возникнет
        :class:`ValueError`.
        """

# ---------------------------------------------------------------------------
# 3. Writer – абстрактный «приёмник» результатов
# ---------------------------------------------------------------------------
class Writer(abc.ABC):
    """Сохраняет результаты в файловую систему / БД / память.

    Writer является *sink*‑ом: он ничего не возвращает в процессе работы.
    Большинство реализаций будут буферизовать данные и сбрасывать их при
    вызове :py:meth:`flush` (автоматически вызывается из ``__exit__``).
    """

    # ----------------------- контекст‑менеджер
    def __enter__(self):  # noqa: D401
        return self

    def __exit__(self, exc_type, exc, tb):  # noqa: D401
        # гарантированно пытаемся сбросить буферы
        with contextlib.suppress(Exception):  # type: ignore[name-defined]
            self.flush()
        return False

    # ----------------------- обязательный метод
    @abc.abstractmethod
    def write(self, outputs: Outputs, meta: MetaBatch, params: Batch):
        """Записать батч результатов.

        Контракт: все три последовательности **одинаковой длины**.
        В случае нарушения реализация может бросить ``ValueError``.
        """
        ...  # pragma: no cover

    # ----------------------- не обязательный, но желательный метод
    def flush(self):  # noqa: D401
        """Сбросить внутренние буферы на диск/в сеть.

        По умолчанию ничего не делает.
        """
        pass

# ---------------------------------------------------------------------------
# public re‑export
# ---------------------------------------------------------------------------
__all__ = [
    "ParamDict",
    "MetaDict",
    "Batch",
    "MetaBatch",
    "Outputs",
    "ParamSource",
    "DataGenerator",
    "Writer",
]
