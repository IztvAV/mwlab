# ========================
# Touchstone I/O
# ========================
import numpy as np
from pathlib import Path

def save_touchstone(filename, freqs, s_data, format='RI', unit='HZ', annotations=None, float_fmt="%.9f", impedance=50):
    """
    Сохраняет S-параметры в Touchstone формате (.sNp)

    Параметры
    ----------
    filename : str | Path
        Имя файла, заканчивающееся на .sNp
    freqs : np.ndarray
        Частоты (в Гц)
    s_data : np.ndarray
        Массив S-параметров (shape = (N, n_ports, n_ports))
    format : str
        Формат представления данных: 'RI', 'MA', 'DB'
    unit : str
        Единица измерения частоты: 'HZ', 'KHZ', 'MHZ', 'GHZ'
    annotations : list[str]
        Строки-комментарии (начинающиеся с '!')
    float_fmt : str
        Формат вывода вещественных чисел
    impedance : float
        Номинальное значение сопротивления (обычно 50 Ом)
    """

    filename = Path(filename)
    freqs = np.asarray(freqs)
    s_data = np.asarray(s_data)

    if freqs.shape[0] != s_data.shape[0]:
        raise ValueError("Длины массива частот и S-параметров не совпадают.")

    if s_data.ndim != 3 or s_data.shape[1] != s_data.shape[2]:
        raise ValueError("Ожидается массив S-параметров размера (N, n_ports, n_ports).")

    n_ports = s_data.shape[1]
    unit = unit.upper()
    format = format.upper()

    unit_factors = {
        'HZ': 1,
        'KHZ': 1e-3,
        'MHZ': 1e-6,
        'GHZ': 1e-9
    }
    if unit not in unit_factors:
        raise ValueError(f"Поддерживаются только единицы: {list(unit_factors)}")

    scale = unit_factors[unit]

    with open(filename, 'w', encoding='ISO-8859-1') as f:
        f.write("! Touchstone file generated by mwlab\n")
        if annotations:
            for line in annotations:
                line = line.strip()
                if not line.startswith("!"):
                    line = "! " + line
                f.write(line + "\n")

        f.write(f"# {unit} S {format} R {impedance}\n")

        for i in range(len(freqs)):
            line = f"{freqs[i] * scale:>12.6f}"
            for row in s_data[i]:
                for val in row:
                    if format == 'RI':
                        line += f" {float_fmt % np.real(val)} {float_fmt % np.imag(val)}"
                    elif format == 'MA':
                        line += f" {float_fmt % np.abs(val)} {float_fmt % np.angle(val, deg=True)}"
                    elif format == 'DB':
                        magnitude_db = 20 * np.log10(np.abs(val))
                        phase = np.angle(val, deg=True)
                        line += f" {float_fmt % magnitude_db} {float_fmt % phase}"
                    else:
                        raise ValueError(f"Неподдерживаемый формат: {format}")
            f.write(line + "\n")

#----------------------------
def load_touchstone(filepath, annotations=False):
    """
    Загружает Touchstone (.sNp) файл

    Параметры
    ----------
    filepath : str | Path
        Путь к файлу
    annotations : bool
        Возвращать ли список аннотаций (! строки)

    Возвращает
    ----------
    freqs : np.ndarray
        Частоты (в Гц)
    s_data : np.ndarray
        Массив S-параметров (N, n_ports, n_ports)
    meta : dict
        Словарь с полями: format, unit, impedance, n_ports
    anno : list[str] (если annotations=True)
        Комментарии (! строки)
    """

    filepath = Path(filepath)
    anno = []
    s_data, freqs = [], []

    # Значения по умолчанию
    format = 'RI'
    unit = 'HZ'
    impedance = 50
    n_ports = None

    with open(filepath, encoding='ISO-8859-1') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            if line.startswith('!'):
                anno.append(line)
                continue

            if line.startswith('#'):
                tokens = line.upper().split()

                valid_units = {'HZ', 'KHZ', 'MHZ', 'GHZ'}
                unit_found = next((t for t in tokens if t in valid_units), None)
                if unit_found is None:
                    raise ValueError(f"Поддерживаются только единицы: {valid_units}")
                unit = unit_found

                valid_formats = {'RI', 'MA', 'DB'}
                format_found = next((t for t in tokens if t in valid_formats), None)
                if format_found is None:
                    raise ValueError(f"Поддерживаются только форматы: {valid_formats}")
                format = format_found

                try:
                    impedance = float(tokens[tokens.index('R') + 1])
                except Exception:
                    impedance = 50
                continue

            parts = line.split()
            if len(parts) < 3:
                continue

            if not freqs:
                n_total = len(parts) - 1
                n_ports = int(np.sqrt(n_total // 2))
                if n_ports ** 2 * 2 != n_total:
                    raise ValueError("Невозможно определить число портов.")
                s_shape = (n_ports, n_ports)

            # Чтение строки + возможное продолжение
            while len(parts) < 2 * n_ports ** 2 + 1:
                parts += next(f).strip().split()

            values = list(map(float, parts))
            freq = values[0]
            freqs.append(freq)

            s_vals = []
            for i in range(n_ports ** 2):
                a, b = values[2 * i + 1], values[2 * i + 2]
                if format == 'RI':
                    s_vals.append(complex(a, b))
                elif format == 'MA':
                    s_vals.append(a * np.exp(1j * np.deg2rad(b)))
                elif format == 'DB':
                    s_vals.append(10 ** (a / 20) * np.exp(1j * np.deg2rad(b)))
            s_matrix = np.array(s_vals).reshape(s_shape)
            s_data.append(s_matrix)

    freqs = np.array(freqs)
    s_data = np.array(s_data)

    # Преобразуем частоты обратно в Гц
    unit_factors = {'HZ': 1, 'KHZ': 1e3, 'MHZ': 1e6, 'GHZ': 1e9}
    freqs *= unit_factors.get(unit, 1)

    meta = dict(format=format, unit=unit, impedance=impedance, n_ports=n_ports)

    if annotations:
        return freqs, s_data, meta, anno
    return freqs, s_data, meta

